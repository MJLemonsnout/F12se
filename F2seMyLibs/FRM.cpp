/* This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://www.wtfpl.net/ for more details. */

#include <math.h>

#include "FRM.h"
#include "Defines.h"
#include "fallout.h"
#include "misc.h"
#include "ntst_loggingpp.hpp"
#include "ntst_stringpp.hpp"

#ifdef FRM_OLD_CODE
static unsigned char defPal[1024] = {
  0x00, 0x00, 0x00, 0x00, 0xEC, 0xEC, 0xEC, 0x00, 0xDC, 0xDC, 0xDC, 0x00, 0xCC, 0xCC, 0xCC, 0x00, 0xBC, 0xBC, 0xBC, 0x00, 0xB0, 0xB0, 0xB0, 0x00, 0xA0, 0xA0, 0xA0, 0x00, 0x90, 0x90, 0x90, 0x00,
  0x80, 0x80, 0x80, 0x00, 0x74, 0x74, 0x74, 0x00, 0x64, 0x64, 0x64, 0x00, 0x54, 0x54, 0x54, 0x00, 0x48, 0x48, 0x48, 0x00, 0x38, 0x38, 0x38, 0x00, 0x28, 0x28, 0x28, 0x00, 0x20, 0x20, 0x20, 0x00,
  0xEC, 0xEC, 0xFC, 0x00, 0xD8, 0xD8, 0xEC, 0x00, 0xC4, 0xC4, 0xDC, 0x00, 0xB0, 0xB0, 0xD0, 0x00, 0xA0, 0xA0, 0xC0, 0x00, 0x90, 0x90, 0xB0, 0x00, 0x80, 0x80, 0xA4, 0x00, 0x70, 0x70, 0x94, 0x00,
  0x60, 0x60, 0x84, 0x00, 0x54, 0x54, 0x78, 0x00, 0x44, 0x44, 0x68, 0x00, 0x38, 0x38, 0x58, 0x00, 0x2C, 0x2C, 0x4C, 0x00, 0x24, 0x24, 0x3C, 0x00, 0x18, 0x18, 0x2C, 0x00, 0x10, 0x10, 0x20, 0x00,
  0xFC, 0xEC, 0xEC, 0x00, 0xEC, 0xD8, 0xD8, 0x00, 0xDC, 0xC4, 0xC4, 0x00, 0xD0, 0xB0, 0xB0, 0x00, 0xC0, 0xA0, 0xA0, 0x00, 0xB0, 0x90, 0x90, 0x00, 0xA4, 0x80, 0x80, 0x00, 0x94, 0x70, 0x70, 0x00,
  0x84, 0x60, 0x60, 0x00, 0x78, 0x54, 0x54, 0x00, 0x68, 0x44, 0x44, 0x00, 0x58, 0x38, 0x38, 0x00, 0x4C, 0x2C, 0x2C, 0x00, 0x3C, 0x24, 0x24, 0x00, 0x2C, 0x18, 0x18, 0x00, 0x20, 0x10, 0x10, 0x00,
  0xF0, 0xB0, 0xFC, 0x00, 0xA8, 0x60, 0xC4, 0x00, 0x60, 0x24, 0x68, 0x00, 0x48, 0x14, 0x4C, 0x00, 0x34, 0x0C, 0x38, 0x00, 0x24, 0x10, 0x28, 0x00, 0x24, 0x04, 0x24, 0x00, 0x18, 0x0C, 0x1C, 0x00,
  0xC8, 0xFC, 0xFC, 0x00, 0x7C, 0xFC, 0xFC, 0x00, 0x0C, 0xD8, 0xE4, 0x00, 0x1C, 0xB8, 0xCC, 0x00, 0x28, 0x9C, 0xB8, 0x00, 0x30, 0x88, 0xA4, 0x00, 0x24, 0x78, 0x90, 0x00, 0x18, 0x68, 0x7C, 0x00,
  0x10, 0x58, 0x6C, 0x00, 0x08, 0x48, 0x58, 0x00, 0x04, 0x38, 0x48, 0x00, 0x00, 0x28, 0x34, 0x00, 0x00, 0x18, 0x20, 0x00, 0x9C, 0xFC, 0xD8, 0x00, 0x84, 0xD8, 0xB4, 0x00, 0x70, 0xB8, 0x98, 0x00,
  0x5C, 0x98, 0x78, 0x00, 0x48, 0x78, 0x5C, 0x00, 0x34, 0x58, 0x40, 0x00, 0x20, 0x38, 0x28, 0x00, 0x50, 0x60, 0x70, 0x00, 0x34, 0x48, 0x54, 0x00, 0x20, 0x30, 0x38, 0x00, 0x50, 0x78, 0x68, 0x00,
  0x20, 0x78, 0x70, 0x00, 0x28, 0x68, 0x70, 0x00, 0x24, 0x60, 0x60, 0x00, 0x24, 0x44, 0x4C, 0x00, 0x20, 0x30, 0x38, 0x00, 0x9C, 0xAC, 0x9C, 0x00, 0x78, 0x94, 0x78, 0x00, 0x58, 0x7C, 0x58, 0x00,
  0x40, 0x68, 0x40, 0x00, 0x58, 0x58, 0x38, 0x00, 0x48, 0x4C, 0x30, 0x00, 0x3C, 0x44, 0x28, 0x00, 0x2C, 0x3C, 0x20, 0x00, 0x24, 0x30, 0x1C, 0x00, 0x18, 0x28, 0x14, 0x00, 0x10, 0x20, 0x10, 0x00,
  0x18, 0x30, 0x18, 0x00, 0x0C, 0x24, 0x10, 0x00, 0x04, 0x1C, 0x08, 0x00, 0x00, 0x14, 0x04, 0x00, 0x00, 0x0C, 0x04, 0x00, 0x9C, 0x9C, 0x8C, 0x00, 0x98, 0x94, 0x78, 0x00, 0x94, 0x88, 0x64, 0x00,
  0x90, 0x7C, 0x50, 0x00, 0x8C, 0x6C, 0x40, 0x00, 0x8C, 0x58, 0x30, 0x00, 0x7C, 0x4C, 0x2C, 0x00, 0x6C, 0x44, 0x28, 0x00, 0x5C, 0x38, 0x20, 0x00, 0x4C, 0x30, 0x1C, 0x00, 0x40, 0x28, 0x18, 0x00,
  0xA4, 0xA4, 0x9C, 0x00, 0x68, 0x48, 0x38, 0x00, 0x58, 0x58, 0x50, 0x00, 0x84, 0x68, 0x58, 0x00, 0x50, 0x40, 0x38, 0x00, 0xBC, 0xBC, 0xBC, 0x00, 0x98, 0xA4, 0xAC, 0x00, 0x7C, 0x90, 0xA0, 0x00,
  0x60, 0x7C, 0x94, 0x00, 0x4C, 0x68, 0x88, 0x00, 0x34, 0x58, 0x7C, 0x00, 0x24, 0x48, 0x70, 0x00, 0x14, 0x3C, 0x64, 0x00, 0x08, 0x30, 0x58, 0x00, 0xCC, 0xCC, 0xFC, 0x00, 0xB0, 0xB0, 0xFC, 0x00,
  0x98, 0x98, 0xFC, 0x00, 0x7C, 0x7C, 0xFC, 0x00, 0x64, 0x64, 0xFC, 0x00, 0x48, 0x48, 0xFC, 0x00, 0x30, 0x30, 0xFC, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0xC4, 0x00,
  0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x40, 0x00, 0xC8, 0xE0, 0xFC, 0x00, 0x94, 0xC4, 0xFC, 0x00, 0x78, 0xB8, 0xFC, 0x00,
  0x60, 0xAC, 0xFC, 0x00, 0x48, 0x9C, 0xFC, 0x00, 0x2C, 0x94, 0xFC, 0x00, 0x14, 0x88, 0xFC, 0x00, 0x00, 0x7C, 0xFC, 0x00, 0x00, 0x6C, 0xDC, 0x00, 0x00, 0x60, 0xC0, 0x00, 0x00, 0x50, 0xA4, 0x00,
  0x00, 0x44, 0x84, 0x00, 0x00, 0x34, 0x68, 0x00, 0x00, 0x24, 0x4C, 0x00, 0x00, 0x18, 0x30, 0x00, 0xA4, 0xD4, 0xF8, 0x00, 0x78, 0xB0, 0xD8, 0x00, 0x64, 0xA0, 0xC8, 0x00, 0x54, 0x90, 0xBC, 0x00,
  0x44, 0x80, 0xAC, 0x00, 0x34, 0x74, 0x9C, 0x00, 0x28, 0x64, 0x8C, 0x00, 0x1C, 0x58, 0x7C, 0x00, 0x14, 0x4C, 0x70, 0x00, 0x08, 0x40, 0x60, 0x00, 0x04, 0x34, 0x50, 0x00, 0x00, 0x28, 0x40, 0x00,
  0x00, 0x20, 0x34, 0x00, 0xB8, 0xE4, 0xFC, 0x00, 0x98, 0xC8, 0xE8, 0x00, 0x7C, 0xAC, 0xD4, 0x00, 0x64, 0x90, 0xC4, 0x00, 0x4C, 0x74, 0xB0, 0x00, 0x38, 0x5C, 0xA0, 0x00, 0x2C, 0x4C, 0x90, 0x00,
  0x20, 0x3C, 0x84, 0x00, 0x18, 0x2C, 0x78, 0x00, 0x10, 0x20, 0x6C, 0x00, 0x08, 0x14, 0x5C, 0x00, 0x04, 0x0C, 0x48, 0x00, 0x00, 0x04, 0x3C, 0x00, 0xDC, 0xE8, 0xFC, 0x00, 0xBC, 0xD4, 0xF8, 0x00,
  0xA0, 0xC0, 0xF4, 0x00, 0x84, 0xB0, 0xF0, 0x00, 0x6C, 0xA0, 0xF0, 0x00, 0x5C, 0x94, 0xF0, 0x00, 0x54, 0x80, 0xD8, 0x00, 0x48, 0x70, 0xC0, 0x00, 0x40, 0x60, 0xA8, 0x00, 0x38, 0x50, 0x90, 0x00,
  0x30, 0x40, 0x78, 0x00, 0x24, 0x30, 0x60, 0x00, 0x1C, 0x24, 0x48, 0x00, 0x14, 0x18, 0x38, 0x00, 0x64, 0xE4, 0x64, 0x00, 0x14, 0x98, 0x14, 0x00, 0x00, 0xA4, 0x00, 0x00, 0x48, 0x50, 0x50, 0x00,
  0x00, 0x6C, 0x00, 0x00, 0x84, 0x8C, 0x8C, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x38, 0x50, 0x68, 0x00, 0x20, 0x28, 0x30, 0x00, 0x60, 0x70, 0x8C, 0x00, 0x28, 0x38, 0x48, 0x00, 0x0C, 0x0C, 0x0C, 0x00,
  0x3C, 0x3C, 0x3C, 0x00, 0x6C, 0x74, 0x6C, 0x00, 0x78, 0x84, 0x78, 0x00, 0x88, 0x94, 0x88, 0x00, 0x94, 0xA4, 0x94, 0x00, 0x60, 0x68, 0x58, 0x00, 0x68, 0x70, 0x60, 0x00, 0x00, 0xF8, 0x3C, 0x00,
  0x08, 0xD4, 0x38, 0x00, 0x10, 0xB4, 0x34, 0x00, 0x14, 0x94, 0x30, 0x00, 0x18, 0x74, 0x28, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xD0, 0xEC, 0xF0, 0x00, 0x88, 0xB8, 0xD0, 0x00, 0x50, 0x7C, 0x98, 0x00,
  0x3C, 0x58, 0x68, 0x00, 0x24, 0x40, 0x50, 0x00, 0x1C, 0x28, 0x34, 0x00, 0x0C, 0x10, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x3A, 0x00 };
#endif

// Generated by wxHexEditor //
static unsigned char defPalNew[256*3] =
    {
    0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEC, 0xEC, 0xEC, 0xD4, 0xD4, 0xD4, 0xB0, 0xB0, 0xB0, 0x90, 0x90, 0x90, 0x78, 0x78, 0x78, 0x58, 0x58, 0x58, 0x3C, 0x3C, 0x3C, 0x2C, 0x2C, 0x2C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEC, 0xEC, 0xFF, 0xCC, 0xCC, 0xF4, 0xA8, 0xA8, 0xDC, 0x90, 0x90, 0xB8, 0x70, 0x70, 0x98, 0x58, 0x58, 0x80, 0x40, 0x40, 0x60, 0x34, 0x34, 0x40, 0x20, 0x20, 0x2C, 0x14, 0x14,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEC, 0xEC, 0xFF, 0xCC, 0xCC, 0xFF, 0xA8, 0xA8, 0xF4, 0x90, 0x90, 0xDC, 0x70, 0x70, 0xB8, 0x58, 0x58, 0x98, 0x40, 0x40, 0x80, 0x34, 0x34, 0x60, 0x20, 0x20, 0x40, 0x14, 0x14, 0x2C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xA8, 0xFF, 0xB8, 0x34, 0xA8, 0x80, 0x18, 0x78, 0x58, 0x0C, 0x50, 0x3C, 0x14, 0x34, 0x34, 0x04, 0x34, 0x24, 0x0C, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0x24, 0xFF, 0xFF, 0x3C, 0xFF, 0xFF, 0x48, 0xFF, 0xDC, 0x34, 0xE4, 0xB8, 0x20,
    0xC0, 0x98, 0x14, 0x98, 0x78, 0x08, 0x78, 0x58, 0x04, 0x50, 0x3C, 0x00, 0x2C, 0x20, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xFF, 0xFF, 0xCC, 0xDC, 0xFF, 0xA0, 0xA0, 0xDC, 0x78, 0x68, 0x98, 0x50, 0x3C, 0x58, 0x2C, 0xCC, 0xA8, 0x88, 0x90, 0x78, 0x50, 0x58, 0x48, 0x2C, 0xB8, 0xDC, 0x88,
    0xCC, 0xDC, 0x2C, 0xCC, 0xB8, 0x3C, 0xA8, 0xA8, 0x34, 0x80, 0x70, 0x34, 0x58, 0x48, 0x2C, 0xFF, 0xFF, 0xFF, 0xDC, 0xFF, 0xDC, 0x98, 0xE4, 0x98, 0x68, 0xB8, 0x68, 0x58, 0x98, 0x98, 0x48, 0x80, 0x78, 0x3C, 0x70, 0x60, 0x2C, 0x60, 0x40, 0x24, 0x48, 0x34, 0x18, 0x3C, 0x20, 0x14, 0x2C, 0x14,
    0x20, 0x48, 0x20, 0x14, 0x34, 0x0C, 0x08, 0x24, 0x04, 0x04, 0x18, 0x00, 0x04, 0x0C, 0x00, 0xFF, 0xFF, 0xFF, 0xDC, 0xFF, 0xFF, 0xB0, 0xFF, 0xFF, 0x88, 0xE4, 0xFF, 0x68, 0xC0, 0xFF, 0x48, 0x98, 0xFF, 0x40, 0x80, 0xE4, 0x3C, 0x70, 0xC0, 0x2C, 0x58, 0xA0, 0x24, 0x48, 0x80, 0x20, 0x3C, 0x68,
    0xFF, 0xFF, 0xFF, 0x58, 0x78, 0xB8, 0x88, 0x98, 0x98, 0x98, 0xB8, 0xF4, 0x58, 0x68, 0x88, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0xFF, 0xE4, 0xA8, 0xFF, 0xB8, 0x80, 0xE4, 0x98, 0x50, 0xCC, 0x78, 0x34, 0xB0, 0x60, 0x18, 0x98, 0x48, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0xE4, 0xFF, 0xB0, 0xB0, 0xFF, 0x78, 0x78, 0xFF, 0x48, 0x48, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xD4, 0x00, 0x00, 0x98, 0x00, 0x00, 0x68, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDC,
    0xFF, 0xFF, 0xA8, 0xFF, 0xFF, 0x78, 0xFF, 0xFF, 0x40, 0xFF, 0xFF, 0x18, 0xFF, 0xE4, 0x00, 0xFF, 0xC0, 0x00, 0xFF, 0xA8, 0x00, 0xFF, 0x88, 0x00, 0xF4, 0x70, 0x00, 0xB8, 0x50, 0x00, 0x80, 0x34, 0x00, 0x48, 0x20, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0xFF, 0xFF, 0xB0, 0xFF, 0xFF, 0x90,
    0xFF, 0xEC, 0x70, 0xFF, 0xD4, 0x50, 0xFF, 0xB0, 0x3C, 0xE4, 0x98, 0x24, 0xCC, 0x80, 0x18, 0xA8, 0x68, 0x08, 0x88, 0x50, 0x04, 0x68, 0x3C, 0x00, 0x50, 0x2C, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0xFF, 0xFF, 0xB0, 0xFF, 0xD4, 0x80, 0xFF, 0xA0, 0x58, 0xFF, 0x80, 0x40,
    0xF4, 0x60, 0x2C, 0xDC, 0x40, 0x20, 0xC0, 0x2C, 0x14, 0xA0, 0x18, 0x08, 0x78, 0x0C, 0x04, 0x60, 0x04, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xFF, 0xFF, 0xC0, 0xFF, 0xFF, 0xA0, 0xFF, 0xEC, 0x90, 0xFF, 0xCC, 0x78, 0xFF, 0xA8, 0x68, 0xFF, 0x88, 0x58,
    0xDC, 0x68, 0x48, 0xA8, 0x48, 0x34, 0x78, 0x34, 0x24, 0x58, 0x20, 0x18, 0xB0, 0xFF, 0xB0, 0x18, 0xFF, 0x18, 0x00, 0xFF, 0x00, 0x88, 0x88, 0x78, 0x00, 0xC0, 0x00, 0xFF, 0xFF, 0xF4, 0x24, 0x24, 0x24, 0xB8, 0x88, 0x58, 0x48, 0x3C, 0x2C, 0xFF, 0xCC, 0xA8, 0x78, 0x58, 0x3C, 0x0C, 0x0C, 0x0C,
    0x60, 0x60, 0x60, 0xC0, 0xD4, 0xC0, 0xDC, 0xF4, 0xDC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x98, 0xB8, 0xA8, 0xA8, 0xCC, 0xB8, 0x60, 0xFF, 0x00, 0x58, 0xFF, 0x08, 0x50, 0xFF, 0x14, 0x48, 0xFF, 0x18, 0x3C, 0xD4, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE4, 0x88,
    0xB8, 0x98, 0x60, 0x88, 0x68, 0x34, 0x50, 0x3C, 0x24, 0x20, 0x14, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x0D, 0x00
    };

RGBImage::RGBImage(const MemBuffer& colorIndicies, size_t startOffset, const PaletteRGB& palette, unsigned w, unsigned h) : width(w), height(h)
    {
    const unsigned pixelCount = width * height;
    const size_t endOffset = startOffset + pixelCount;
    if (!rgbArray.Resize(pixelCount * 3))
        return;
    unsigned char* out = static_cast<unsigned char*>(rgbArray.GetAddress());
    for (size_t i = startOffset; i < endOffset; ++i)
        {
        unsigned char colorNum = colorIndicies.Get8(i);
        const unsigned char* colorVal = &palette[colorNum * 3];
        // Cause I hate to remeber *++ order.
        *out = *colorVal; ++out; ++colorVal; // r
        *out = *colorVal; ++out; ++colorVal; // g
        *out = *colorVal; ++out; // b
        }
    }

RGBAImage::RGBAImage(const MemBuffer& colorIndicies, size_t startOffset, const PaletteRGB& palette, unsigned w, unsigned h)
        :RGBImage(colorIndicies, startOffset, palette, w, h)
    {
    if (rgbArray.empty()) // RGBImage constuctor failed or image is empty.
        return;
    const unsigned pixelCount = width * height;
    const size_t endOffset = startOffset + pixelCount;
    if (!alphaArray.Resize(pixelCount))
        return;
    unsigned char* out = static_cast<unsigned char*>(alphaArray.GetAddress());
    for (size_t i = startOffset; i < endOffset; ++i)
        {
        if (colorIndicies.Get8(i) == 0)
            *out = 0;
        else
            *out = 255;
        ++out;
        }
    }

FrmWorker::FrmWorker() : currentgamma(1.0)
    {
#ifdef FRM_OLD_CODE
    fheader.bfType = 0x4D42;
    fheader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + PALETTE_SIZE;
    fheader.bfReserved1 = 0;
    fheader.bfReserved2 = 0;

    header.biSize = sizeof(BITMAPINFOHEADER);
    header.biPlanes = 1;
    header.biBitCount = 8;
    header.biCompression = 0;
    header.biSizeImage = 0;
    header.biXPelsPerMeter = 0;
    header.biYPelsPerMeter = 0;
    header.biClrUsed = 0;
    header.biClrImportant = 0;
#endif
    }

static const char* lstfiles[] = {"art\\items\\items.lst",
                          "art\\critters\\critters.lst",
                          "art\\scenery\\scenery.lst",
                          "art\\walls\\walls.lst",
                          "art\\tiles\\tiles.lst",
                          "art\\misc\\misc.lst",
                          "art\\intrface\\intrface.lst",
                          "art\\inven\\inven.lst",
                          "art\\heads\\heads.lst",
                          "art\\backgrnd\\backgrnd.lst",
                          "art\\skilldex\\skilldex.lst"};
void FrmWorker::InitAll(FileFinder& ff)
    {
    for (uint i = 0; i < IMAGES_TYPES_NUM; ++i)
        {
        MemBuffer buf = ff.GetFile(lstfiles[i]);
        frmlist[i].LoadFromMemory(buf);
        // TODO need delete for some lst files. but f12se doesn't use them.
        /*frmlist[i].DeleteComment(";");
        frmlist[i].DeleteComment(",");*/
        for (uint j = 0; j < frmlist[i].size(); j++)
            frmlist[i][j] = Trim(frmlist[i][j]);
        }
    for (int i = 0; i < GAMMA_ARRAY_SIZE; i++)
        {
        int gamma = (int)(pow(i, currentgamma)) * 4;
        if (gamma > 255)
            gamma = 255;
        gammatable[i] = gamma;
        }
#ifdef FRM_OLD_CODE
    if (!LoadPal("color.pal", ff, palmain))
        {
        ntst_log_error("Can't load main palette from color.pal");
        memcpy(palmain, defPal, sizeof(palmain));
        }
#endif
    if (!LoadPal("color.pal", ff, palMain))
        {
        ntst_log_error("Can't load main palette from color.pal");
        memcpy(palMain, defPalNew, sizeof(palMain));
        }
    //savemem(palMain, sizeof(palMain));
    }

static const char* frmdir[] = {"art\\items\\",
                        "art\\critters\\",
                        "art\\scenery\\",
                        "art\\walls\\",
                        "art\\tiles\\",
                        "art\\misc\\",
                        "art\\intrface\\",
                        "art\\inven\\",
                        "art\\heads\\",
                        "art\\backgrnd\\",
                        "art\\skilldex\\"};

std::string FrmWorker::GetNameFromId(int32 id)
    {
    uint8 obtype = (id >> 24) & 0xF;
    /*if (obtype > 10)
        obtype = 0;*/
    uint16 lstind = id & 0xFFF;
    /*if (lstind == 0xFFF)
        lstind = 0;*/
    if (obtype >= NTST_ARRAY_LEN(frmdir))
        {
        std::string error = "Invalid image id " + ntst::to_string_hex_pref(id);
        ntst_log_error(error);
        return error;
        }
    if (lstind >= frmlist[obtype].size())
        {
        std::string error = "Invalid image id " + ntst::to_string_hex_pref(id);
        ntst_log_error(error);
        return error;
        }
    std::string filename = frmdir[obtype] + frmlist[obtype][lstind];
    if (obtype == CRITTERS)
        filename = filename +"aa.frm";
    return filename;
    }

bool FrmWorker::LoadFrmByNameInRGBA(const std::string& name, FileFinder& ff, RGBAImage &out)
    {
    bool fileFound = ff.FindFile(name);
    if (!fileFound)
        return false;
    MemBuffer buf = ff.GetFoundFile();

    if (buf.GetSize() < 0x004A)
        {
        ntst_log_error("The file size is too small(" + ntst::to_string(buf.GetSize()) + ") for frm file: " + name);
        return false;
        }
    uint16 width = buf.GetInv16(0x003E);
    uint16 height = buf.GetInv16(0x0040);
    unsigned frameoffset = buf.GetInv32(0x0022) + 0x003E + 0xC;
    std::string palname = name;
	std::string::size_type dotpos = palname.rfind('.');
    //TODO filename check
	if (dotpos == std::string::npos)
		ntst_log_warning("No dot in filename: " + palname);
	if ((uint)dotpos + 4 != palname.length())
		ntst_log_warning("Unexpected dot position in filename: " + palname);
	palname.resize(dotpos + 1);
	palname = palname + "pal";
	PaletteRGB* palout;
	if (!LoadPal(palname, ff, palFrm))
		palout = &palMain;
	else
		{
		palout = &palFrm;
		ntst_log_info("Image " + name + " has palette.");
		}
	RGBAImage result(buf, frameoffset, *palout, width, height);
	out = result;
	return true;
    }

bool FrmWorker::LoadFrmByIdInRGBA(uint32 id, FileFinder& ff, RGBAImage &out)
    {
    std::string name = GetNameFromId(id);
    return LoadFrmByNameInRGBA(name, ff, out);
    }

bool FrmWorker::LoadPal(const std::string& filename, FileFinder& ff, PaletteRGB& pal)
    {
    bool fileFound = ff.FindFile(filename);
    if (!fileFound)
        return false;
    MemBuffer buf = ff.GetFoundFile();
    if (buf.GetSize() < 256*3)
        {
        ntst_log_error("The file size is too small(" + ntst::to_string(buf.GetSize()) + ") for palette: " + filename);
        return false;
        }

    uint8 *filepal = (uint8*)buf.GetAddress();
    for (int i = 0; i < 255; i++)
        {
        unsigned char r = *filepal;
        filepal++;
        unsigned char g = *filepal;
        filepal++;
        unsigned char b = *filepal;
        filepal++;
        if (r >= GAMMA_ARRAY_SIZE || g >= GAMMA_ARRAY_SIZE || b >= GAMMA_ARRAY_SIZE)
            {
            r=0;g=0;b=0;
            }
        pal[i*3 + 0] = gammatable[r];
        pal[i*3 + 1] = gammatable[g];
        pal[i*3 + 2] = gammatable[b];
        }
	return true;
    }

#ifdef FRM_OLD_CODE
static int32 zero4 = 0;//4 нулевых байта для добавления в конец
bool FrmWorker::LoadFrmByNameInBmp(const std::string& name, FileFinder& ff, MemBuffer &out)
	{
	int i, j, alignedwidth;
	int32 frameoffset;
	std::string palname;

    bool fileFound =  ff.FindFile(name);
    if (!fileFound)
        return false;
    MemBuffer buf = ff.GetFoundFile();

    if (buf.GetSize() < 0x004A)
        {
        ntst_log_error("The file size is too small(" + ntst::to_string(buf.GetSize()) + ") for frm file: " + name);
        return false;
        }
    // TODO rewrite with checks
	void *addr = buf.GetAddress();
	uint16 biwidth;
	uint16 biheight;
	memcpy(&biwidth, (void*)((uintptr_t)addr + 0x003E), 2);
	memcpy(&biheight, (void*)((uintptr_t)addr + 0x0040), 2);
	memcpy(&frameoffset, (void*)((uintptr_t)addr + 0x0022), 4);
	header.biWidth = ntst_bytes_swap16(biwidth);
	header.biHeight = ntst_bytes_swap16(biheight);
	frameoffset = ntst_bytes_swap32(frameoffset) + 0x003E + 0xC;
	void *frame = (void*)((uint)addr + frameoffset);
	alignedwidth = AlignValUp(header.biWidth, 4);
	int colorarraysize = alignedwidth * header.biHeight;
	void* colorarray = malloc(colorarraysize);
	int zerocount = alignedwidth - header.biWidth;
	for (i = 0, j = header.biHeight - 1; i < header.biHeight ; i++, j--)
		{
		memcpy((void*)((uint)colorarray + (j * alignedwidth)), (void*)((uint)frame + (i * header.biWidth)), header.biWidth);
		memcpy((void*)((uint)colorarray + header.biWidth), &zero4, zerocount);
		}

	palname = name;
	size_t dotpos = palname.rfind('.');
    //TODO filename check
	palname.resize(dotpos + 1);
	palname = palname + "pal";
	int32* palout;
	if (!LoadPal(palname, ff, palfrm))
		palout = palmain;
	else
		palout = palfrm;
    size_t totalSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + PALETTE_SIZE + colorarraysize;
	fheader.bfSize = totalSize;
	void *result = malloc(totalSize);
	memcpy(result, &fheader, sizeof(fheader));
	memcpy((void*)((uintptr_t)result + sizeof(fheader)), &header, sizeof(header));
	memcpy((void*)((uintptr_t)result + sizeof(fheader) + sizeof(header)), palout, PALETTE_SIZE);
	memcpy((void*)((uintptr_t)result + totalSize - colorarraysize), colorarray, colorarraysize);
	out.Assign(result, totalSize);
	free(colorarray);
	return true;
	}

bool FrmWorker::LoadPal(const std::string& filename, FileFinder& ff, int32 pal[256])
    {
    bool fileFound = ff.FindFile(filename);
    if (!fileFound)
        return false;
    MemBuffer buf = ff.GetFoundFile();
    if (buf.GetSize() < 768)
        {
        ntst_log_error("The file size is too small(" + ntst::to_string(buf.GetSize()) + ") for palette: " + filename);
        return false;
        }

    uint8 *filepal = (uint8*)buf.GetAddress();
    for (int i = 0; i < 255; i++)
        {
        unsigned char r = *filepal;
        filepal++;
        unsigned char g = *filepal;
        filepal++;
        unsigned char b = *filepal;
        filepal++;
        if (r >= GAMMA_ARRAY_SIZE || g >= GAMMA_ARRAY_SIZE || b >= GAMMA_ARRAY_SIZE)
            {
            r=0;g=0;b=0;
            }
        r = gammatable[r];
        g = gammatable[g];
        b = gammatable[b];
        pal[i] = (r << 16) + (g << 8) + b;
        }
    pal[0] = 0xFFFFFF; // TODO remove this dirty code!!!
	return true;
    }

bool FrmWorker::LoadFrmByIdInBmp(uint32 id, FileFinder& ff, MemBuffer &out)
    {
    std::string name = GetNameFromId(id);
    return LoadFrmByNameInBmp(name, ff, out);
    }

#endif

void FrmWorker::SetGamma(double gamma)
    {
    if (gamma > 1.179993)
        currentgamma = 1.179993;
    else if (gamma < 1.0)
        currentgamma = 1.0;
    else
        currentgamma = gamma;
    }
